<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="format-detection" content="telephone=no">
<title>CYBER PRISM - V10.3 FULLSCREEN</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root { 
        --cyan: #00f3ff; --pink: #ff00ff; --dark: #050510; 
        --glass: rgba(0, 20, 40, 0.85); --gold: #ffd700; --red: #ff3333; --white: #ffffff;
    }
    
    body { 
        margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; 
        color: #fff;
        /* PREVENT SELECTION AND MENU POPUPS ON IOS */
        user-select: none; -webkit-user-select: none; 
        -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;
        touch-action: manipulation; -webkit-touch-action: manipulation;
    }
    
    /* === CRT OVERLAY EFFECT === */
    .crt::before {
        content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        z-index: 999; background-size: 100% 2px, 3px 100%; pointer-events: none;
    }
    .crt::after {
        content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
        background: rgba(18, 16, 16, 0.1); opacity: 0; z-index: 999; pointer-events: none;
        animation: flicker 0.15s infinite;
    }
    @keyframes flicker { 0% { opacity: 0.02; } 50% { opacity: 0.05; } 100% { opacity: 0.02; } }

    /* GLOBAL CANVAS */
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; touch-action: none; }
    #prev-c { position: relative !important; top: auto !important; left: auto !important; width: 100% !important; height: 100% !important; z-index: 1 !important; background: transparent !important; }

    /* === 3D MOVING BACKGROUND === */
    .world-bg {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
        background: radial-gradient(circle at center, #0a0a15 0%, #000 100%);
        perspective: 1000px; overflow: hidden;
    }
    .grid-floor {
        position: absolute; bottom: -50%; left: -50%; width: 200%; height: 100%;
        background-image: 
            linear-gradient(rgba(0, 243, 255, 0.3) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 243, 255, 0.3) 1px, transparent 1px);
        background-size: 50px 50px;
        transform: rotateX(60deg);
        animation: planeMove 5s linear infinite;
        mask-image: linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 80%);
    }
    @keyframes planeMove { 0% { background-position: 0 0; } 100% { background-position: 0 50px; } }

    /* PARTICLES */
    .dust { position: absolute; background: var(--cyan); border-radius: 50%; animation: floatDust 10s infinite linear; opacity: 0.5; }
    @keyframes floatDust { 0% { transform: translateY(0) rotate(0deg); opacity:0; } 50% { opacity:0.8; } 100% { transform: translateY(-100vh) rotate(360deg); opacity:0; } }

    /* UI SCREENS */
    .screen { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        display: flex; flex-direction: column; align-items: center; justify-content: center; 
        pointer-events: auto; z-index: 10; transition: opacity 0.3s, transform 0.3s;
    }
    .screen:not(.hidden) { z-index: 100; pointer-events: auto; }
    .interactive { pointer-events: auto !important; background: rgba(0,0,0,0.6); backdrop-filter: blur(3px); }
    .hidden { display: none !important; opacity: 0; pointer-events: none !important; transform: scale(0.95); }
    
    .menu-anim { animation: hologramOpen 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    @keyframes hologramOpen { from { opacity: 0; transform: scale(0.9) translateY(20px); filter: blur(5px); } to { opacity: 1; transform: scale(1) translateY(0); filter: blur(0); } }

    /* TEXT & EFFECTS */
    .glitch-text {
        position: relative; color: #fff; font-size: 56px; font-weight: 900; letter-spacing: 8px;
        text-shadow: 2px 2px 0px var(--cyan), -2px -2px 0px var(--pink);
        animation: glitchSkew 3s infinite linear alternate-reverse;
    }
    @keyframes glitchSkew {
        0% { text-shadow: 2px 2px 0 var(--cyan), -2px -2px 0 var(--pink); transform: skew(0deg); }
        20% { text-shadow: 2px 2px 0 var(--cyan), -2px -2px 0 var(--pink); transform: skew(0deg); }
        21% { text-shadow: -2px 0 0 var(--red), 2px 0 0 var(--cyan); transform: skew(10deg); }
        22% { text-shadow: 2px 0 0 var(--pink), -2px 0 0 var(--gold); transform: skew(-10deg); }
        23% { text-shadow: 2px 2px 0 var(--cyan), -2px -2px 0 var(--pink); transform: skew(0deg); }
        100% { transform: skew(0deg); }
    }

    /* PANELS */
    .cyber-panel {
        background: linear-gradient(135deg, rgba(10, 20, 30, 0.95) 0%, rgba(5, 10, 15, 0.98) 100%);
        border: 1px solid #333; border-top: 2px solid var(--cyan); border-bottom: 2px solid var(--cyan);
        box-shadow: 0 0 30px rgba(0, 243, 255, 0.1); padding: 20px;
        clip-path: polygon(0 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
        position: relative; pointer-events: auto !important;
        max-height: 80vh; display: flex; flex-direction: column; overflow: hidden;
    }
    .cyber-panel::after {
        content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 20px;
        background: linear-gradient(90deg, transparent, rgba(0, 243, 255, 0.2), transparent);
        transform: rotate(45deg); animation: scanPanel 4s infinite linear; pointer-events: none;
    }
    @keyframes scanPanel { 0% { top: -50%; } 100% { top: 150%; } }

    /* BUTTONS */
    .btn { 
        position: relative; background: rgba(0, 20, 30, 0.6); border: 1px solid var(--cyan); color: var(--cyan); 
        padding: 12px 30px; font-family: 'Orbitron'; font-size: 16px; margin: 8px; 
        text-shadow: 0 0 5px var(--cyan); overflow: hidden; transition: 0.3s; cursor: pointer;
        clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        user-select: none; -webkit-user-select: none; pointer-events: auto; z-index: 150; display: inline-block;
        touch-action: manipulation; -webkit-touch-action: manipulation; -webkit-tap-highlight-color: transparent;
    }
    .btn::before {
        content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
        background: linear-gradient(90deg, transparent, var(--cyan), transparent);
        opacity: 0.2; transition: 0.4s; transform: skewX(-20deg);
    }
    .btn:hover { background: rgba(0, 243, 255, 0.15); color: #fff; box-shadow: 0 0 15px var(--cyan); transform: scale(1.05); }
    .btn:hover::before { left: 100%; }
    .btn:active { transform: scale(0.95); }

    /* HUD */
    #ui-hud { justify-content: space-between; padding: 20px; box-sizing: border-box; align-items: stretch; pointer-events: auto; background: transparent !important; backdrop-filter: none !important; }
    .top-bar { width: 100%; display: flex; justify-content: space-between; align-items: flex-start; }
    
    .stat-box { 
        text-align: right; background: rgba(0,0,0,0.6); padding: 10px; 
        border-bottom-left-radius: 15px; border-right: 2px solid var(--cyan); 
        box-shadow: -5px 5px 15px rgba(0, 243, 255, 0.1);
    }
    .stat-row { display: flex; align-items: center; justify-content: flex-end; margin-bottom: 2px; font-size: 12px; letter-spacing: 1px; color: #aaa; }
    .stat-row span { margin-left: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 5px currentColor; }

    #btn-pause {
        position: absolute; top: 20px; right: 20px; z-index: 200;
        width: 40px; height: 40px; background: rgba(0,0,0,0.5); border: 1px solid var(--cyan);
        color: var(--cyan); font-family: 'Orbitron'; font-weight: bold;
        display: flex; align-items: center; justify-content: center;
        transform: skewX(-10deg); transition: 0.2s; box-shadow: 0 0 10px rgba(0,243,255,0.2);
        animation: pulseBorder 2s infinite; pointer-events: auto; cursor: pointer;
    }
    #btn-pause:hover { background: var(--cyan); color: #000; box-shadow: 0 0 20px var(--cyan); }
    @keyframes pulseBorder { 0% { box-shadow: 0 0 5px rgba(0,243,255,0.2); } 50% { box-shadow: 0 0 15px rgba(0,243,255,0.6); } 100% { box-shadow: 0 0 5px rgba(0,243,255,0.2); } }

    /* BARS & NOTIFICATIONS */
    .bar-con { 
        width: 220px; height: 12px; background: rgba(10,10,10,0.8); border: 1px solid #444; 
        transform: skewX(-20deg); margin-bottom: 6px; position: relative; overflow: hidden; 
    }
    .bar { height: 100%; width: 0%; position: relative; z-index: 2; transition: width 0.1s linear; }
    #hp-bar { background: linear-gradient(90deg, #00ff00, #00f3ff); }
    #hp-lag { background: #fff; width: 100%; position: absolute; top:0; left:0; z-index: 1; opacity: 0.5; }
    #heat-frame.jammed { border-color: #f00; animation: shake 0.2s infinite; }
    #heat-bar { background: linear-gradient(90deg, #ffdd00, #ff0000); }
    #ult-bar { background: linear-gradient(90deg, #ff00cc, #9d00ff); }
    #xp-bar-fill { background: linear-gradient(90deg, #444, #aaa); } 
    .bar-label { font-size: 9px; color: #fff; position: absolute; top: 0; left: 5px; z-index: 3; text-shadow: 0 0 2px #000; line-height: 12px; transform: skewX(20deg); }

    /* CONTROLS */
    .zone { 
        position: absolute; bottom: 40px; width: 140px; height: 140px; 
        border: 1px dashed rgba(255,255,255,0.2); border-radius: 50%; z-index: 50; 
        pointer-events: auto !important; touch-action: none; -webkit-touch-action: none;
    }
    #z-l { left: 40px; } #z-r { right: 40px; }
    .stick { position: absolute; width: 50px; height: 50px; background: rgba(0, 243, 255, 0.3); border: 2px solid var(--cyan); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; box-shadow: 0 0 15px var(--cyan); }
    .joy-base { position: absolute; width: 100px; height: 100px; background: rgba(255,255,255,0.05); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; border: 1px solid rgba(255,255,255,0.2); }

    #btn-ult { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%) skewX(-15deg); width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; border: 2px solid #333; color: #333; background: rgba(0,0,0,0.5); transition: 0.3s; z-index: 100; pointer-events: auto; cursor: pointer; }
    #btn-ult.ready { border-color: var(--pink); color: var(--pink); box-shadow: 0 0 25px var(--pink), inset 0 0 10px var(--pink); background: rgba(255, 0, 255, 0.1); animation: pulseUlt 1s infinite; }
    @keyframes pulseUlt { 0% { transform: translateX(-50%) skewX(-15deg) scale(1); } 50% { transform: translateX(-50%) skewX(-15deg) scale(1.05); } 100% { transform: translateX(-50%) skewX(-15deg) scale(1); } }

    /* TUTORIAL MESSAGE */
    #tut-msg {
        position: absolute; top: 15%; width: 100%; text-align: center;
        font-size: 20px; font-weight: bold; color: var(--gold);
        text-shadow: 0 0 10px var(--gold); letter-spacing: 2px;
        pointer-events: none; z-index: 150; display: none;
        background: rgba(0,0,0,0.4); padding: 10px 0;
        border-top: 1px solid var(--gold); border-bottom: 1px solid var(--gold);
    }

    /* MENUS */
    h2 { color: var(--cyan); margin-bottom: 20px; letter-spacing: 4px; border-bottom: 2px solid var(--cyan); padding-bottom: 10px; display: inline-block; position: relative; }
    h2::after { content:''; position: absolute; right: 0; bottom: -5px; width: 30px; height: 5px; background: var(--cyan); }

    .list-con { display: flex; width: 85%; height: 65%; gap: 20px; flex-direction: row; }
    .col { flex: 1; overflow-y: auto; display: flex; flex-direction: column; padding-right: 5px; }
    .col-r { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; position: relative; padding: 10px; border-left: 1px solid #333; }
    .row { padding: 15px; border: 1px solid rgba(255,255,255,0.1); margin-bottom: 8px; cursor: pointer; display: flex; justify-content: space-between; transition: 0.2s; background: rgba(0,0,0,0.3); pointer-events: auto !important; position: relative; overflow: hidden; }
    .row:hover { background: rgba(0, 243, 255, 0.1); border-color: var(--cyan); transform: translateX(5px); }
    .row.active { border: 1px solid var(--cyan); background: rgba(0, 243, 255, 0.15); box-shadow: 0 0 10px rgba(0,243,255,0.1); }
    
    #card-con { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; pointer-events: auto !important; }
    .card { width: 180px; height: 260px; background: rgba(0, 20, 40, 0.95); border: 1px solid var(--cyan); padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; transition: 0.3s; position: relative; overflow: hidden; box-shadow: 0 0 15px rgba(0,0,0,0.5); cursor: pointer; }
    .card:hover { transform: translateY(-10px) scale(1.05); box-shadow: 0 0 30px rgba(0, 243, 255, 0.3); background: #001; border-color: #fff; }
    
    .ach-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 15px; width: 100%; padding: 10px; }
    .ach-card { background: rgba(0,0,0,0.6); border: 1px solid #444; padding: 15px; display: flex; flex-direction: column; opacity: 0.6; transition: 0.3s; position: relative; }
    .ach-card.unlocked { border-color: var(--gold); opacity: 1; background: rgba(30, 30, 10, 0.7); box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.1); }
    
    #ach-notify { position: absolute; top: -120px; left: 50%; transform: translateX(-50%); width: 340px; background: rgba(0, 20, 0, 0.95); border: 1px solid var(--gold); padding: 15px; text-align: center; pointer-events: none; transition: top 0.5s ease-out; z-index: 200; box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); clip-path: polygon(0 0, 100% 0, 100% 85%, 90% 100%, 10% 100%, 0 85%); }
    #ach-notify.show { top: 30px; }

    #msg-oh { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #f00; font-size: 24px; font-weight: bold; border: 2px solid #f00; padding: 10px 30px; display: none; background: rgba(0,0,0,0.8); text-shadow: 0 0 10px #f00; box-shadow: 0 0 30px #f00; animation: blink 0.1s infinite; z-index: 50; pointer-events: none; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    #lvl-up-msg { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); color: var(--pink); font-size: 14px; font-weight: bold; text-shadow: 0 0 10px var(--pink); pointer-events: none; opacity: 0; transition: opacity 0.5s; text-align: center; }
    #lvl-up-msg.show { opacity: 1; animation: floatUp 1s forwards; }
    @keyframes floatUp { from { transform: translate(-50%, 20px); } to { transform: translate(-50%, 0); } }
</style>
</head>
<body class="crt">

<canvas id="c"></canvas>
<div class="world-bg"><div class="grid-floor"></div><div id="dust-con"></div></div>

<div id="ach-notify">
    <h3 style="color:var(--gold); margin:0; letter-spacing:2px;">ACHIEVEMENT UNLOCKED</h3>
    <p id="ach-txt" style="margin:5px 0 0 0; color:#fff; font-size:12px;"></p>
    <p id="ach-rew" style="margin:5px 0 0 0; color:var(--cyan); font-weight:bold;"></p>
</div>

<div id="tut-msg">INITIALIZING TRAINING SIM...</div>

<div id="ui-hud" class="screen hidden">
    <button id="btn-pause" onclick="Game && Game.togglePause && Game.togglePause()">II</button>
    <div class="top-bar">
        <div>
            <div class="bar-con"><div id="hp-lag" class="bar"></div><div id="hp-bar" class="bar"></div><span class="bar-label">INTEGRITY</span></div>
            <div class="bar-con" id="heat-frame"><div id="heat-bar" class="bar"></div><span class="bar-label" id="heat-txt">HEAT</span></div>
            <div class="bar-con" style="border-color:#555"><div id="ult-bar" class="bar"></div><span class="bar-label">SYSTEM CHARGE</span></div>
            <div class="bar-con" style="border-color:#444; height:4px; margin-top:2px;"><div id="xp-bar-fill" class="bar"></div></div>
        </div>
        <div class="stat-box">
            <div class="stat-row">WAVE <span id="d-wave" style="color:#fff">1</span></div>
            <div class="stat-row">HOSTILES <span id="d-left" style="color:#f00">0</span></div>
            <div class="stat-row">BITS <span id="d-bits" style="color:var(--cyan)">0</span></div>
            <div class="stat-row">LEVEL <span id="d-lvl" style="color:#fff">1</span></div>
        </div>
    </div>
    <div id="msg-oh">WEAPON JAMMED</div>
    <div id="lvl-up-msg">FIRMWARE UPDATE<br><span id="lvl-bonus" style="color:#fff; font-size:12px;">+5% DMG</span></div>
    <div id="btn-ult" onclick="Game && Game.triggerUlt && Game.triggerUlt()">ULT</div>
    <div id="z-l" class="zone"></div><div id="z-r" class="zone"></div>
    <div id="joy-l" class="joy-base"></div><div id="st-l" class="stick"></div>
    <div id="joy-r" class="joy-base"></div><div id="st-r" class="stick"></div>
</div>

<div id="s-menu" class="screen interactive menu-anim" style="flex-wrap: wrap;">
    <div style="position: absolute; top: 20px; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0 30px; width: calc(100% - 60px); pointer-events: auto; z-index: 150;">
        <button class="btn" style="border-color:var(--gold); color:var(--gold); margin: 0;" onclick="window.openAchievements()">ACHIEVEMENTS</button>
        <button class="btn" style="border-color:var(--pink); color:var(--pink); margin: 0;" onclick="window.openLeaderboard()">LEADERBOARD</button>
        <button class="btn" style="border-color:#fff; color:#fff; margin: 0;" onclick="window.toggleFS()">FULLSCREEN</button>
    </div>
    <div style="text-align:center; padding:40px; background:radial-gradient(circle, rgba(0,0,0,0.8) 0%, transparent 70%); margin-top: 80px;">
        <h1 class="glitch-text">CYBER PRISM</h1>
        <h3 style="color:var(--cyan); letter-spacing:4px; margin-top:-10px; margin-bottom:40px; opacity:0.8;">V10.3 // ONLINE</h3>
        <div style="display:flex; flex-direction:column; align-items:center;">
            <button class="btn" style="width:240px; font-weight:bold; border-color:#fff; font-size:18px;" onclick="window.startGame()">DEPLOY UNIT</button>
            <button class="btn" style="width:240px; border-color:#0f0; color:#0f0;" onclick="window.startTutorial()">TUTORIAL</button>
            <button class="btn" style="width:240px;" onclick="window.openHangar()">HANGAR</button>
            <button class="btn" style="width:240px;" onclick="window.openShop()">BLACK MARKET</button>
            <button class="btn" style="width:240px;" onclick="window.openLab()">R&D LAB</button>
        </div>
    </div>
</div>

<div id="s-pause" class="screen hidden interactive menu-anim">
    <div class="cyber-panel" style="text-align:center; width:300px; pointer-events: auto;">
        <h2 style="margin-top:0;">SYSTEM PAUSED</h2>
        <div style="color:#aaa; font-size:12px; margin-bottom:10px;">ACTIVE SYNERGIES: <span id="pause-syn" style="color:var(--gold)">NONE</span></div>
        <button class="btn" style="width:100%; pointer-events: auto;" onclick="Game && Game.togglePause && Game.togglePause()">RESUME MISSION</button>
        <button class="btn" style="width:100%; border-color:#0f0; color:#0f0; pointer-events: auto;" onclick="Game && Game.buyRepair && Game.buyRepair()">EMERGENCY REPAIR (500 BITS)</button>
        <button class="btn" style="width:100%; border-color:var(--red); color:var(--red); pointer-events: auto;" onclick="Game && Game.abort && Game.abort()">ABORT MISSION</button>
    </div>
</div>
<div id="s-over" class="screen hidden interactive menu-anim">
    <div class="cyber-panel" style="text-align:center; border-color:var(--red); box-shadow:0 0 40px rgba(255,0,0,0.2); pointer-events: auto;">
        <h1 class="glitch-text" style="color:#f00; text-shadow:2px 2px 0px #800;">CRITICAL FAILURE</h1>
        <div style="margin:20px 0; font-size:18px;">
            <p>XP GAINED: <span id="go-xp" style="color:var(--pink)">0</span></p>
            <p>BITS COLLECTED: <span id="go-bits" style="color:var(--cyan)">0</span></p>
        </div>
        <button class="btn" style="pointer-events: auto;" onclick="Game && Game.abort && Game.abort()">RETURN TO BASE</button>
    </div>
</div>
<div id="s-list" class="screen hidden interactive menu-anim">
    <div style="width:85%; display:flex; justify-content:space-between; align-items:flex-end; margin-bottom:10px;">
        <h1 id="list-title" class="glitch-text" style="font-size:36px; margin:0;">HANGAR</h1>
        <div style="font-size:20px; background:rgba(0,0,0,0.7); padding:5px 15px; border:1px solid var(--cyan);">BITS: <span id="ui-bits" style="color:var(--cyan)">0</span></div>
    </div>
    <div class="cyber-panel list-con" style="pointer-events: auto;">
        <div class="col">
            <div id="list-tabs" style="display:flex; margin-bottom:15px;">
                <button id="tab-chassis" class="btn" style="margin:0 10px 0 0; font-size:12px; pointer-events: auto;" onclick="Menus && Menus.setShopTab && Menus.setShopTab('CHASSIS')">CHASSIS</button>
                <button id="tab-modules" class="btn" style="margin:0; font-size:12px; pointer-events: auto;" onclick="Menus && Menus.setShopTab && Menus.setShopTab('MODULES')">MODULES</button>
            </div>
            <div id="list-items"></div>
        </div>
        <div id="list-detail" class="col-r"></div>
    </div>
    <button class="btn" style="margin-top:20px; z-index:999; pointer-events: auto;" onclick="Menus && Menus.home && Menus.home()">BACK</button>
</div>
<div id="s-ach" class="screen hidden interactive menu-anim">
    <div style="width:85%; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <h2 style="color:var(--gold); border-color:var(--gold); margin:0;">ACHIEVEMENTS</h2>
        <div style="color:#888;">UNLOCKED: <span id="ach-count" style="color:#fff">0/0</span></div>
    </div>
    <div class="cyber-panel" style="width:85%; height:60%; overflow-y:auto; border-color:var(--gold); pointer-events: auto;">
        <div id="ach-list" class="ach-grid"></div>
    </div>
    <button class="btn" style="margin-top:20px; border-color:var(--gold); color:var(--gold); pointer-events: auto;" onclick="Menus && Menus.home && Menus.home()">BACK</button>
</div>
<div id="s-up" class="screen hidden interactive menu-anim">
    <div class="cyber-panel" style="align-items:center; padding:30px; pointer-events: auto;">
        <h2>SYSTEM UPGRADE</h2>
        <div id="card-con"></div>
        <button class="btn" id="btn-reroll" style="width:200px; margin-top:20px; pointer-events: auto;" onclick="Game && Game.rerollAugments && Game.rerollAugments()">REROLL (50 BITS)</button>
    </div>
</div>

<script>
const SAVE_KEY = 'CYBER_PRISM_V10_2';
function toggleFullScreen() {
  if (!document.fullscreenElement) {
    if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(e=>console.log(e));
    else if(document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
  } else {
    if (document.exitFullscreen) document.exitFullscreen();
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
  }
}

// Wrapper functions for button handlers to ensure they work
window.startGame = () => { if(Game && Game.start) Game.start(); };
window.startTutorial = () => { if(Game && Game.startTutorial) Game.startTutorial(); };
window.openHangar = () => { if(Menus && Menus.open) Menus.open('hangar'); };
window.openShop = () => { if(Menus && Menus.open) Menus.open('shop'); };
window.openLab = () => { if(Menus && Menus.open) Menus.open('lab'); };
window.openAchievements = () => { if(Menus && Menus.open) Menus.open('achievements'); };
window.openLeaderboard = () => { if(Menus && Menus.open) Menus.open('leaderboard'); };
window.toggleFS = () => { toggleFullScreen(); };

// Add touch support to buttons - ensure they work on mobile
function setupButtonHandlers() {
    // Setup all buttons with click handlers
    document.querySelectorAll('button').forEach(btn => {
        if (!btn.dataset.touchHandlersSet) {
            // Prevent double-tap zoom
            btn.style.touchAction = 'manipulation';
            
            // Touch events
            btn.addEventListener('touchstart', function(e) {
                this.style.opacity = '0.7';
                this.style.backgroundColor = 'rgba(0, 243, 255, 0.25)';
            }, { passive: true });
            
            btn.addEventListener('touchend', function(e) {
                this.style.opacity = '1';
                this.style.backgroundColor = '';
                // Trigger the click
                if (this.onclick) {
                    this.onclick.call(this, e);
                }
            }, { passive: true });
            
            btn.addEventListener('touchcancel', function(e) {
                this.style.opacity = '1';
                this.style.backgroundColor = '';
            }, { passive: true });
            
            btn.dataset.touchHandlersSet = 'true';
        }
    });
    
    // Setup clickable divs (like ULT button and zones)
    document.querySelectorAll('[onclick]').forEach(el => {
        if (!el.dataset.touchHandlersSet && el.tagName !== 'BUTTON') {
            el.style.touchAction = 'manipulation';
            
            el.addEventListener('touchstart', function(e) {
                this.style.opacity = '0.7';
            }, { passive: true });
            
            el.addEventListener('touchend', function(e) {
                this.style.opacity = '1';
                // Get the onclick handler string and execute it
                const onclickStr = this.getAttribute('onclick');
                if (onclickStr) {
                    new Function(onclickStr).call(this);
                }
            }, { passive: true });
            
            el.addEventListener('touchcancel', function(e) {
                this.style.opacity = '1';
            }, { passive: true });
            
            el.dataset.touchHandlersSet = 'true';
        }
    });
    
    // Setup row elements (menu items)
    document.querySelectorAll('.row').forEach(el => {
        if (!el.dataset.touchHandlersSet) {
            el.style.touchAction = 'manipulation';
            
            el.addEventListener('touchstart', function(e) {
                this.style.opacity = '0.7';
            }, { passive: true });
            
            el.addEventListener('touchend', function(e) {
                this.style.opacity = '1';
                if (this.onclick) {
                    this.onclick.call(this, e);
                }
            }, { passive: true });
            
            el.addEventListener('touchcancel', function(e) {
                this.style.opacity = '1';
            }, { passive: true });
            
            el.dataset.touchHandlersSet = 'true';
        }
    });
}

// Initialize button handlers when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupButtonHandlers);
} else {
    setupButtonHandlers();
}

// Re-setup after menus open (new buttons created dynamically)
setInterval(() => {
    setupButtonHandlers();
}, 500);

// Also setup on page visibility change
document.addEventListener('visibilitychange', setupButtonHandlers);

/* DATA & CONFIG */
const ACHIEVEMENTS = [
    { id: 'first_blood', name: 'FIRST BLOOD', desc: 'Destroy your first enemy.', reward: 100, req: (s) => s.totalKills >= 1 },
    { id: 'novice', name: 'NOVICE PILOT', desc: 'Destroy 100 enemies.', reward: 500, req: (s) => s.totalKills >= 100 },
    { id: 'slayer', name: 'CYBER SLAYER', desc: 'Destroy 1,000 enemies.', reward: 2500, req: (s) => s.totalKills >= 1000 },
    { id: 'survivor', name: 'SURVIVOR', desc: 'Reach Wave 5.', reward: 300, req: (s) => s.highestWave >= 5 },
    { id: 'veteran', name: 'VETERAN', desc: 'Reach Wave 15.', reward: 1500, req: (s) => s.highestWave >= 15 },
    { id: 'elite', name: 'ELITE', desc: 'Reach Wave 30.', reward: 5000, req: (s) => s.highestWave >= 30 },
    { id: 'rich', name: 'CRYPTO MINER', desc: 'Hold 5,000 Bits.', reward: 1000, req: (s) => s.currentBits >= 5000 },
    { id: 'hoarder', name: 'DATA HOARDER', desc: 'Hold 15,000 Bits.', reward: 3000, req: (s) => s.currentBits >= 15000 },
    { id: 'millionaire', name: 'TYCOON', desc: 'Hold 50,000 Bits.', reward: 10000, req: (s) => s.currentBits >= 50000 },
    { id: 'synergy', name: 'OVERPOWERED', desc: 'Unlock a Synergy.', reward: 500, req: (s) => s.synergyUnlocked },
    { id: 'max_mod', name: 'ENGINEER', desc: 'Level 5 Module.', reward: 1000, req: (s) => s.maxedMod },
    { id: 'collector', name: 'COLLECTOR', desc: 'Own 3 Chassis.', reward: 1000, req: (s) => s.ownedChassis >= 3 },
    { id: 'boss_kill', name: 'TITAN FALL', desc: 'Defeat a Boss.', reward: 2000, req: (s) => s.bossKilled },
    { id: 'sniper', name: 'SNIPER', desc: 'Kill enemy > 400px away.', reward: 200, req: (s) => s.longShot },
    { id: 'daredevil', name: 'DAREDEVIL', desc: 'Kill enemy < 50px away.', reward: 200, req: (s) => s.closeKill },
    { id: 'untouchable', name: 'UNTOUCHABLE', desc: 'Finish Wave 5 with 100% HP.', reward: 5000, req: (s) => s.untouchable }
];
const API_BASE = window.location.hostname === 'localhost' ? 'http://localhost:3000/api' : '/api';
async function apiCall(endpoint, options = {}) {
    try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
            headers: { 'Content-Type': 'application/json', ...options.headers },
            ...options
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
    } catch (e) {
        console.error('API call failed:', e);
        return null;
    }
}
async function submitScore(wave, kills, bits) {
    const playerName = localStorage.getItem('playerName') || 'Anonymous';
    const data = await apiCall('/leaderboard/submit', {
        method: 'POST',
        body: JSON.stringify({ playerName, wave, kills, bits, prestigeLevel: 0 })
    });
    if (data) console.log('Score submitted:', data.message);
}
async function getLeaderboard() {
    const data = await apiCall('/leaderboard');
    return data || { entries: [] };
}
let Data = { bits: 1000, owned: ['viper'], modules: [], equipped: { chassis: 'viper', mods: [] }, chassisXP: { 'viper': {xp:0, lvl:1} }, modLevels: {}, achievements: [], stats: { totalKills: 0, highestWave: 0, bossKilled: false } };

const CHASSIS = {
    'viper':   { name: 'Viper',   hp: 100, spd: 4, heatRate: 2.0, ult: 'OVERCLOCK', color: '#00f3ff', cost: 0, desc: 'Balanced fighter. Standard issue.' },
    'tank':    { name: 'Rhino',   hp: 200, spd: 2, heatRate: 1.5, ult: 'AEGIS', color: '#00ff00', cost: 2000, desc: 'Heavy armor. Slow but tough.' },
    'swift':   { name: 'Stratus', hp: 60,  spd: 6, heatRate: 3.5, ult: 'PHASE', color: '#ffff00', cost: 1500, desc: 'High speed. Overheats quickly.' },
    'lancer':  { name: 'Lancer',  hp: 120, spd: 5, heatRate: 2.5, ult: 'OVERDRIVE', color: '#ffd700', cost: 3500, desc: 'Melee specialist. Ult rams enemies.' },
    'void':    { name: 'Void',    hp: 90,  spd: 3.5, heatRate: 2.0, ult: 'CONSTRUCT', color: '#9d00ff', cost: 4500, desc: 'Summons automated turrets.' },
    'pyro':    { name: 'Ignis',   hp: 120, spd: 3.5, heatRate: 2.5, ult: 'INFERNO', color: '#ff5500', cost: 3000, desc: 'Thermal weaponry specialist.' },
    'spectre': { name: 'Spectre', hp: 80,  spd: 5, heatRate: 1.8, ult: 'RAILGUN', color: '#a020f0', cost: 5000, desc: 'Stealth ops. High burst damage.' },
    'paladin': { name: 'Paladin', hp: 150, spd: 3, heatRate: 1.2, ult: 'REFLECT', color: '#fff', cost: 4000, desc: 'Defensive powerhouse. Runs cool.' },
    'falcon':  { name: 'Falcon',  hp: 110, spd: 4.5, heatRate: 2.2, ult: 'DASH', color: '#ff4500', cost: 2500, desc: 'Agile interceptor. Quick dashes.' },
    'behemoth':{ name: 'Behemoth',hp: 250, spd: 1.5, heatRate: 1.0, ult: 'BARRAGE', color: '#8b0000', cost: 6000, desc: 'Massive firepower. Very slow.' },
    'phantom': { name: 'Phantom', hp: 70,  spd: 5.5, heatRate: 2.8, ult: 'CLOAK', color: '#696969', cost: 5500, desc: 'Invisible for short periods.' },
    'titan':   { name: 'Titan',   hp: 180, spd: 2.5, heatRate: 1.8, ult: 'SHIELD', color: '#daa520', cost: 4800, desc: 'Energy shields. High defense.' }
};
const MODULES = {
    'tesla': { name: 'Tesla Coil', cost: 1000, color: '#00f3ff', desc: 'Shocks nearby enemies.', func: (p, l) => { p.flags.tesla = l; } },
    'regen': { name: 'Nanobots', cost: 1500, color: '#0f0', desc: 'Slowly repairs hull.', func: (p, l) => { setInterval(()=>{if(Game.active && p.hp<p.maxHp)p.hp+=l;}, 1000); } },
    'scope': { name: 'Targeting AI', cost: 800, color: '#f00', desc: 'Increases critical chance.', func: (p, l) => { p.crit += 0.05*l; } },
    'orbit': { name: 'Grav Orbs', cost: 2500, color: '#ffd700', desc: 'Shield orbs circle ship.', func: (p, l) => { p.flags.orbit = l; } },
    'nova':  { name: 'Nova Core', cost: 3000, color: '#ff5500', desc: 'Enemies explode on death.', func: (p, l) => { p.flags.nova = l; } },
    'drone': { name: 'Combat Drone', cost: 2000, color: '#ff1493', desc: 'Deploys a helper drone.', func: (p, l) => { p.flags.drone = l; } },
    'shield':{ name: 'Energy Shield', cost: 1800, color: '#00ffff', desc: 'Absorbs damage periodically.', func: (p, l) => { p.flags.shield = true; p.shieldMax = 50 * l; p.shield = p.shieldMax; } },
    'boost': { name: 'Speed Boost', cost: 1200, color: '#32cd32', desc: 'Increases movement speed.', func: (p, l) => { p.spd *= 1.1 * l; } },
    'mine':  { name: 'Proximity Mines', cost: 2200, color: '#dc143c', desc: 'Drops mines that explode.', func: (p, l) => { p.flags.mine = l; } },
    'laser': { name: 'Laser Beam', cost: 3500, color: '#ff6347', desc: 'Fires a continuous laser.', func: (p, l) => { p.flags.laser = l; } }
};
const AUG_POOL = [
    { id: 'dmg', type:'OFF', n: 'Overcharge', d: '+20% Damage', f: p=>p.dmg*=1.2 },
    { id: 'multi', type:'OFF', n: 'Split Chamber', d: '+1 Projectile, -10% Dmg', f: p=>{p.multi++; p.dmg*=0.9;} },
    { id: 'pierce', type:'OFF', n: 'Phase Rounds', d: '+1 Pierce', f: p=>p.pierce++ },
    { id: 'crit', type:'OFF', n: 'Lethal Tempo', d: '+10% Crit Chance', f: p=>p.crit+=0.1 },
    { id: 'blast', type:'OFF', n: 'Blast Payload', d: 'Bullets explode on impact', f: p=>p.blastRadius+=30 },
    { id: 'rear', type:'OFF', n: 'Rear Guard', d: 'Shoot backwards', f: p=>p.flags.rear=true },
    { id: 'homing', type:'OFF', n: 'Smart Chip', d: 'Bullets seek targets', f: p=>p.homing+=0.04 },
    { id: 'spd', type:'UTIL', n: 'Thruster Tune', d: '+10% Speed', f: p=>p.spd*=1.1 },
    { id: 'cool', type:'UTIL', n: 'Heat Sink', d: '+30% Cooling Rate', f: p=>p.coolRate*=1.3 }, 
    { id: 'hp', type:'DEF', n: 'Hull Plating', d: '+30 Max HP', f: p=>{p.maxHp+=30; p.hp+=30; p.vHp+=30;} },
    { id: 'vamp', type:'DEF', n: 'Leech System', d: 'Heal 2 HP on kill', f: p=>p.leech+=2 },
    { id: 'ricochet', type:'UTIL', n: 'Rubberized', d: 'Bullets bounce off walls', f: p=>p.bounce++ },
    { id: 'dodge', type:'DEF', n: 'Phase Shift', d: '+15% Dodge Chance', f: p=>p.dodge+=0.15 },
    { id: 'frost', type:'UTIL', n: 'Cryo Rounds', d: 'Slows enemies on hit', f: p=>p.flags.frost=true }
];
const SYNERGIES = [
    { req: ['tesla', 'overclock', 'dmg'], mod:'tesla', id: 'storm', n: 'THUNDER LORD', d: 'Tesla coil arcs faster and chains.' },
    { req: ['orbit', 'blast'], mod:'orbit', id: 'planet', n: 'PLANETARY DESTRUCTION', d: 'Orbitals explode on contact.' },
    { req: ['pierce', 'ricochet'], id: 'geom', n: 'SIMPLE GEOMETRY', d: 'Bounced shots gain +50% damage.' },
    { req: ['homing', 'scope'], mod:'scope', id: 'curve', n: 'MAGIC BULLET', d: 'Projectiles never miss.' },
    { req: ['regen', 'hp'], mod:'regen', id: 'jug', n: 'JUGGERNAUT', d: 'Massive HP regen when stationary.' },
    { req: ['nova', 'frost'], mod:'nova', id: 'shatter', n: 'ICE SHATTER', d: 'Frozen enemies explode shards.' },
    { req: ['rear', 'multi'], id: 'star', n: 'DEATH STAR', d: 'Shoot in 8 directions.' }
];
const ENEMY_DB = [
    { id: 'drone', tier: 1, hp: 30, bits: 5, spd: 2, c: '#ff0000', r: 12, shape: 'arrow', ai: 'seek' },
    { id: 'fast', tier: 2, hp: 20, bits: 8, spd: 4, c: '#ffaa00', r: 10, shape: 'dart', ai: 'seek' },
    { id: 'tank', tier: 3, hp: 100, bits: 20, spd: 1, c: '#00ff00', r: 20, shape: 'square', ai: 'seek' },
    { id: 'sniper', tier: 3, hp: 40, bits: 25, spd: 1.5, c: '#fff', r: 15, shape: 'tri', ai: 'keepDist', wpn: 'sniper' },
    { id: 'cube', tier: 4, hp: 150, bits: 40, spd: 1.5, c: '#0000ff', r: 25, shape: 'square', ai: 'seek' },
    { id: 'shooter', tier: 2, hp: 50, bits: 15, spd: 2, c: '#f0f', r: 15, shape: 'tri', ai: 'seek', wpn: 'pew' }
];
const BOSS_DB = [
    { id: 'boss_prime', name: 'Prime Titan', hp: 2000, spd: 0.5, c: '#ff0000', r: 80, shape: 'boss', ai: 'boss', bits: 500, ult: 'OVERCLOCK' },
    { id: 'boss_void', name: 'Void Leviathan', hp: 2500, spd: 0.4, c: '#9d00ff', r: 90, shape: 'boss', ai: 'boss_void', bits: 600, ult: 'CONSTRUCT' },
    { id: 'boss_fire', name: 'Inferno Behemoth', hp: 1800, spd: 0.6, c: '#ff5500', r: 75, shape: 'boss', ai: 'boss_fire', bits: 550, ult: 'INFERNO' },
    { id: 'boss_ice', name: 'Frost Colossus', hp: 2200, spd: 0.3, c: '#00f3ff', r: 85, shape: 'boss', ai: 'boss_ice', bits: 650, ult: 'PHASE' },
    { id: 'boss_storm', name: 'Storm Overlord', hp: 1900, spd: 0.7, c: '#ffd700', r: 70, shape: 'boss', ai: 'boss_storm', bits: 700, ult: 'RAILGUN' }
];

// Global speed multiplier to make gameplay feel a bit snappier
const SPEED_MULT = 1.15;

/* GRAPHICS & INPUT */
const C = document.getElementById('c'); const ctx = C.getContext('2d', {alpha: false});
let W, H, DPR, isMobile; const Resize = () => { DPR = window.devicePixelRatio || 1; W = window.innerWidth; H = window.innerHeight; C.width = W * DPR; C.height = H * DPR; C.style.width = W + 'px'; C.style.height = H + 'px'; ctx.scale(DPR, DPR); isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768; InitStars(); };
window.addEventListener('resize', Resize); Resize();
const dc = document.getElementById('dust-con');
for(let i=0; i<(isMobile ? 15 : 30); i++) {
    let d = document.createElement('div'); d.className='dust'; d.style.left = Math.random()*100+'%'; d.style.top = Math.random()*100+'%';
    d.style.width = d.style.height = (Math.random()*4+1)+'px'; d.style.animationDuration = (10+Math.random()*20)+'s'; d.style.animationDelay = -Math.random()*20+'s'; dc.appendChild(d);
}
let Stars = []; const InitStars = () => { Stars = []; for(let i=0; i<100; i++) Stars.push({x:Math.random()*W, y:Math.random()*H, s:Math.random()*2, a:Math.random()}); };
const Neon = (ctx, pathFn, color, glowStrength=20, fillAlpha=0.1) => {
    ctx.save(); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.shadowBlur = glowStrength; ctx.shadowColor = color;
    ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.beginPath(); pathFn(ctx); ctx.stroke();
    ctx.shadowBlur = 0; ctx.lineWidth = 1.5; ctx.strokeStyle = '#fff'; ctx.globalAlpha = 0.8; ctx.stroke();
    ctx.fillStyle = color; ctx.globalAlpha = fillAlpha; ctx.fill(); ctx.restore();
};
const Draw = {
    stars(t, P) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        Stars.forEach(s => {
            let ox = (P.vx || 0) * s.s * 0.5; let oy = (P.vy || 0) * s.s * 0.5;
            s.x -= ox; s.y -= oy; if(s.x < 0) s.x = W; if(s.x > W) s.x = 0; if(s.y < 0) s.y = H; if(s.y > H) s.y = 0;
            ctx.globalAlpha = 0.3 + (Math.sin(t*0.002 + s.a*10)*0.2); ctx.beginPath(); ctx.arc(s.x, s.y, s.s, 0, 6.28); ctx.fill();
        }); ctx.globalAlpha = 1;
    },
    exhaust(ctx, x, y, size, color) {
        ctx.save(); ctx.translate(x, y); ctx.globalCompositeOperation = 'lighter';
        for(let i=0; i<3; i++) {
            let offset = Math.random() * 2; ctx.fillStyle = color; ctx.globalAlpha = (1 - (i*0.3)) * 0.6; ctx.shadowBlur = 20; ctx.shadowColor = color;
            ctx.beginPath(); ctx.arc(-size*0.5 - (i*6), (Math.random()-0.5)*3, size*(0.6 - i*0.1) + offset, 0, 6.28); ctx.fill();
        } ctx.restore();
    },
    module(ctx, type) {
        ctx.save();
        if(type==='tesla') { ctx.strokeStyle='#00f3ff'; ctx.lineWidth=2; ctx.shadowColor='#00f3ff'; ctx.shadowBlur=10; ctx.beginPath(); ctx.moveTo(-5, -5); ctx.lineTo(-5, -15); ctx.lineTo(-2, -18); ctx.moveTo(5, -5); ctx.lineTo(5, -15); ctx.lineTo(2, -18); ctx.stroke(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(-2,-18,1,0,6.28); ctx.arc(2,-18,1,0,6.28); ctx.fill(); } 
        else if(type==='scope') { ctx.fillStyle='#f00'; ctx.shadowColor='#f00'; ctx.shadowBlur=10; ctx.beginPath(); ctx.arc(8, 5, 2, 0, 6.28); ctx.fill(); ctx.strokeStyle='#333'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(8, 5, 4, 0, 6.28); ctx.stroke(); } 
        else if(type==='nova') { ctx.fillStyle='#ff5500'; ctx.shadowColor='#ff5500'; ctx.shadowBlur=15; let s = 1 + Math.sin(Date.now()/200)*0.2; ctx.beginPath(); ctx.arc(0,0,3*s,0,6.28); ctx.fill(); } 
        else if(type==='regen') { ctx.strokeStyle='#0f0'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-5, 5); ctx.lineTo(-10, 5); ctx.lineTo(-10, 10); ctx.moveTo(5, 5); ctx.lineTo(10, 5); ctx.lineTo(10, 10); ctx.stroke(); }
        ctx.restore();
    },
    ship(ctx, x, y, ang, type, color, mods=[], overheated=false) {
        ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
        let displayColor = overheated ? '#ff3333' : color; let glow = overheated ? 50 : 25;
        if(!overheated) Draw.exhaust(ctx, -15, 0, 12, displayColor);
        else { ctx.fillStyle = 'rgba(100,100,100,0.5)'; ctx.beginPath(); ctx.arc(-15, (Math.random()-0.5)*10, Math.random()*5, 0, 6.28); ctx.fill(); }
        if(mods.includes('orbit') || (Game.player && Game.player.flags && Game.player.flags.orbit)) {
             let t = Date.now()/300; let count = 0; if(Game.player && Game.player.flags) count = Game.player.flags.orbit || 0; else if(mods.includes('orbit')) count = Data.modLevels['orbit'] || 1;
             for(let i=0; i<count; i++) {
                 let oa = t + (i * (6.28/count)); let ox = Math.cos(oa)*40; let oy = Math.sin(oa)*40;
                 ctx.save(); ctx.translate(ox, oy); ctx.rotate(-ang); ctx.fillStyle = '#ffd700'; ctx.shadowBlur=10; ctx.shadowColor=ctx.fillStyle; ctx.beginPath(); ctx.arc(0,0,4,0,6.28); ctx.fill(); ctx.restore();
             }
        }
        let path = (c) => {
            if(type==='viper') { c.moveTo(20,0); c.lineTo(-10,12); c.lineTo(-5,0); c.lineTo(-10,-12); c.closePath(); }
            else if (type==='tank') { c.moveTo(15,0); c.lineTo(10,10); c.lineTo(-15,12); c.lineTo(-15,-12); c.lineTo(10,-10); c.closePath(); }
            else if (type==='swift') { c.moveTo(25,0); c.lineTo(-10,5); c.lineTo(-5,0); c.lineTo(-10,-5); c.closePath(); c.moveTo(-10,5); c.lineTo(-20, 10); c.lineTo(-15, 0); c.lineTo(-20, -10); c.lineTo(-10, -5); }
            else if (type==='pyro') { c.moveTo(20,0); c.quadraticCurveTo(0, 15, -10, 0); c.quadraticCurveTo(0, -15, 20, 0); }
            else if (type==='spectre') { c.moveTo(20,0); c.lineTo(-5,15); c.lineTo(-10,5); c.lineTo(-15,10); c.lineTo(-10,0); c.lineTo(-15,-10); c.lineTo(-10,-5); c.lineTo(-5,-15); c.closePath(); }
            else if (type==='paladin') { c.moveTo(15,0); c.lineTo(5,5); c.lineTo(5,15); c.lineTo(-5,15); c.lineTo(-5,5); c.lineTo(-15,0); c.lineTo(-5,-5); c.lineTo(-5,-15); c.lineTo(5,-15); c.lineTo(5,-5); c.closePath(); }
            else if (type==='lancer') { c.moveTo(30,0); c.lineTo(-10, 8); c.lineTo(-10, 3); c.lineTo(-20, 6); c.lineTo(-20, -6); c.lineTo(-10, -3); c.lineTo(-10, -8); c.closePath(); }
            else if (type==='void') { c.moveTo(10,0); c.lineTo(-10,15); c.lineTo(-5,0); c.lineTo(-10,-15); c.closePath(); c.moveTo(10,0); c.arc(10,0,4,0,6.28); }
            else { c.moveTo(15,0); c.lineTo(-10,10); c.lineTo(-10,-10); c.closePath(); }
        };
        Neon(ctx, path, displayColor, glow, 0.15);
        mods.forEach(m => Draw.module(ctx, m)); ctx.fillStyle='#fff'; ctx.shadowBlur=10; ctx.shadowColor='#fff'; ctx.beginPath(); ctx.arc(10,0,2,0,6.28); ctx.fill(); ctx.restore();
    },
    enemy(ctx, e) {
        ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.ang);
        if(e.elite) { ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 30; ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0,0, e.r + 5, 0, 6.28); ctx.stroke(); }
        Draw.exhaust(ctx, -e.r, 0, 10, e.c);
        let shapeFn = (c,r) => {
            if(e.shape==='arrow') { c.moveTo(r,0); c.lineTo(-r, r); c.lineTo(-r/2, 0); c.lineTo(-r, -r); c.closePath(); }
            else if(e.shape==='dart') { c.moveTo(r,0); c.lineTo(-r, r/2); c.lineTo(-r, -r/2); c.closePath(); }
            else if(e.shape==='square') c.rect(-r,-r,r*2,r*2);
            else if(e.shape==='tri') { c.moveTo(r,0); c.lineTo(-r, r); c.lineTo(-r, -r); c.closePath(); }
            else if(e.shape==='boss') { c.moveTo(r,0); c.lineTo(r/2,r); c.lineTo(-r/2,r); c.lineTo(-r,0); c.lineTo(-r/2,-r); c.lineTo(r/2,-r); c.closePath(); }
        };
        let color = e.frozen ? '#00f3ff' : e.c; Neon(ctx, (c)=>shapeFn(c,e.r), color, e.boss ? 50 : (e.elite ? 40 : 25), 0.2); ctx.restore();
    },
    turret(ctx, t) {
        ctx.save(); ctx.translate(t.x, t.y); ctx.strokeStyle='#9d00ff'; ctx.shadowBlur=10; ctx.shadowColor='#9d00ff'; ctx.beginPath(); ctx.arc(0,0,10,0,6.28); ctx.stroke(); ctx.rotate(t.angle); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.rect(0, -3, 15, 6); ctx.fill(); ctx.restore();
    }
};

/* INPUT SYSTEM */
const Input = {
    lx:0, ly:0, la:false, rx:0, ry:0, ra:false, lox:0, loy:0, rox:0, roy:0,
    init() {
        // Prevent default touch behavior on canvas to stop scrolling/zooming/selecting
        const C = document.getElementById('c');
        C.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
        C.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        C.addEventListener('touchend', e => e.preventDefault(), { passive: false });

        const bind = (z, j, s, k) => {
            const Z=document.getElementById(z), J=document.getElementById(j), S=document.getElementById(s);
            const move = (cx, cy) => {
                let dx = cx - Input[k+'ox'], dy = cy - Input[k+'oy'];
                let d = Math.hypot(dx, dy), max=40;
                if(d>max) { dx *= max/d; dy *= max/d; }
                S.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                Input[k+'x'] = dx/max; Input[k+'y'] = dy/max;
            };
            
            // Mouse
            Z.addEventListener('mousedown', e=>{
                e.preventDefault(); Input[k+'a']=true; Input[k+'ox']=e.clientX; Input[k+'oy']=e.clientY;
                J.style.display=S.style.display='block'; J.style.left=e.clientX+'px'; J.style.top=e.clientY+'px'; S.style.left=e.clientX+'px'; S.style.top=e.clientY+'px'; S.style.transform = `translate(-50%, -50%)`;
            });
            window.addEventListener('mousemove', e=>{ if(Input[k+'a']) move(e.clientX, e.clientY); });
            window.addEventListener('mouseup', e=>{ Input[k+'a']=false; Input[k+'x']=Input[k+'y']=0; J.style.display=S.style.display='none'; });

            // Touch - Passive false required to prevent scrolling/zooming on iOS
            Z.addEventListener('touchstart', e=>{
                e.preventDefault(); Input[k+'a']=true; 
                let t = e.changedTouches[0];
                Input[k+'ox']=t.clientX; Input[k+'oy']=t.clientY;
                J.style.display=S.style.display='block'; J.style.left=t.clientX+'px'; J.style.top=t.clientY+'px'; S.style.left=t.clientX+'px'; S.style.top=t.clientY+'px'; S.style.transform = `translate(-50%, -50%)`; 
            }, { passive: false });
            
            Z.addEventListener('touchmove', e=>{ 
                e.preventDefault(); 
                if(Input[k+'a']) { let t=e.changedTouches[0]; move(t.clientX, t.clientY); } 
            }, { passive: false });
            
            const end = e=>{ e.preventDefault(); Input[k+'a']=false; Input[k+'x']=Input[k+'y']=0; J.style.display=S.style.display='none'; };
            Z.addEventListener('touchend', end, { passive: false }); 
            Z.addEventListener('touchcancel', end, { passive: false });
        };
        bind('z-l','joy-l','st-l','l'); bind('z-r','joy-r','st-r','r');
        // Keyboard controls: WASD move, Arrow keys aim, K = fire, Space = ULT, Esc = pause
        const _keys = {};
        const recomputeFromKeys = () => {
            // Left stick (movement) from WASD
            let lx = 0, ly = 0;
            if(_keys['KeyD']) lx += 1; if(_keys['KeyA']) lx -= 1;
            if(_keys['KeyS']) ly += 1; if(_keys['KeyW']) ly -= 1;
            // Normalize to -1..1
            Input.lx = Math.max(-1, Math.min(1, lx));
            Input.ly = Math.max(-1, Math.min(1, ly));

            // Right stick (aim) from Arrow keys
            let rx = 0, ry = 0;
            if(_keys['ArrowRight']) rx += 1; if(_keys['ArrowLeft']) rx -= 1;
            if(_keys['ArrowDown']) ry += 1; if(_keys['ArrowUp']) ry -= 1;
            if(rx !== 0 || ry !== 0) {
                // Normalize diagonal to unit vector
                let m = Math.hypot(rx, ry) || 1; Input.rx = rx / m; Input.ry = ry / m;
            } else {
                // Leave existing aim if no arrow keys pressed (e.g. mouse/touch)
                Input.rx = Input.rx || 0; Input.ry = Input.ry || 0;
            }
        };

        window.addEventListener('keydown', e=>{
            if(e.code === 'Space') { e.preventDefault(); Game.triggerUlt(); return; }
            if(e.code === 'Escape') { e.preventDefault(); Game.togglePause(); return; }
            // Fire button
            if(e.code === 'KeyK') { Input.ra = true; e.preventDefault(); }
            _keys[e.code] = true; recomputeFromKeys();
        });

        window.addEventListener('keyup', e=>{
            if(e.code === 'KeyK') { Input.ra = false; }
            delete _keys[e.code]; recomputeFromKeys();
        });
    }
};

const AI = {
    seek: (e, p) => { let ang = Math.atan2(p.y - e.y, p.x - e.x); let s = e.spd * (e.frozen?0.5:1); e.vx = e.vx * 0.95 + Math.cos(ang) * s * 0.05; e.vy = e.vy * 0.95 + Math.sin(ang) * s * 0.05; e.ang = ang; },
    keepDist: (e, p) => { let dist = Math.hypot(p.x - e.x, p.y - e.y); let ang = Math.atan2(p.y - e.y, p.x - e.x); let moveAng = dist < 200 ? ang + Math.PI : (dist > 350 ? ang : ang + 1.57); let s = e.spd * (e.frozen?0.5:1); e.vx = e.vx * 0.9 + Math.cos(moveAng) * s * 0.1; e.vy = e.vy * 0.9 + Math.sin(moveAng) * s * 0.1; e.ang = ang; },
    boss: (e, p) => {
        if(e.y < 150) e.vy = 1; else e.vy = Math.sin(Date.now()/500); e.vx = Math.cos(Date.now()/1000) * 2; e.ang = 1.57;
        if(Game.frame % 60 === 0) {
            let ang = Math.atan2(p.y - e.y, p.x - e.x); Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*5, vy:Math.sin(ang)*5, life:100, dmg:20, sz:8, color:'#f00', enemy:true});
            for(let i=0; i<6; i++) { let a = i * (6.28/6) + (Game.frame/100); Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*3, vy:Math.sin(a)*3, life:150, dmg:15, sz:5, color:'#f00', enemy:true}); }
        }
    },
    boss_void: (e, p) => {
        e.vx = Math.cos(Date.now()/800) * 1.5; e.vy = Math.sin(Date.now()/800) * 1.5; e.ang = Math.atan2(p.y - e.y, p.x - e.x);
        if(Game.frame % 80 === 0) {
            for(let i=0; i<8; i++) { let a = i * (6.28/8); Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*4, vy:Math.sin(a)*4, life:120, dmg:25, sz:6, color:'#9d00ff', enemy:true}); }
        }
    },
    boss_fire: (e, p) => {
        let ang = Math.atan2(p.y - e.y, p.x - e.x); e.vx = Math.cos(ang) * 0.5; e.vy = Math.sin(ang) * 0.5; e.ang = ang;
        if(Game.frame % 50 === 0) {
            let spread = 0.3; for(let i=-2; i<=2; i++) { let a = ang + i*spread; Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*6, vy:Math.sin(a)*6, life:80, dmg:30, sz:10, color:'#ff5500', enemy:true}); }
        }
    },
    boss_ice: (e, p) => {
        if(e.y < 100) e.vy = 0.8; else e.vy = 0; e.vx = Math.cos(Date.now()/1200) * 3; e.ang = 1.57;
        if(Game.frame % 100 === 0) {
            let ang = Math.atan2(p.y - e.y, p.x - e.x); Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*2, vy:Math.sin(ang)*2, life:200, dmg:10, sz:4, color:'#00f3ff', enemy:true, frozen:true});
            for(let i=0; i<4; i++) { let a = i * (6.28/4) + Date.now()/500; Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*5, vy:Math.sin(a)*5, life:150, dmg:20, sz:7, color:'#00f3ff', enemy:true}); }
        }
    },
    boss_storm: (e, p) => {
        e.vx = Math.cos(Date.now()/600) * 2; e.vy = Math.sin(Date.now()/600) * 2; e.ang = Math.atan2(p.y - e.y, p.x - e.x);
        if(Game.frame % 40 === 0) {
            let ang = Math.atan2(p.y - e.y, p.x - e.x); Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*8, vy:Math.sin(ang)*8, life:60, dmg:35, sz:12, color:'#ffd700', enemy:true});
            for(let i=0; i<3; i++) { let a = ang + (i-1)*0.5; Game.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*4, vy:Math.sin(a)*4, life:100, dmg:15, sz:5, color:'#ffd700', enemy:true}); }
        }
    }
};

/* GAME ENGINE */
const Game = {
    state: 'menu', active: false, wave:1, xp:0, bits:0,
    player: { flags: {} }, enemies: [], bullets: [], particles: [], turrets: [], floatingTexts: [],
    shake: 0, frame: 0, waveTotal: 0, spawnedCount: 0, jamTimer: 0, rerollCost: 50,
    isTutorial: false, tutStep: 0, tutTimer: 0,

    start() {
        if(this.active) return;
        let cKey = Data.equipped.chassis; let cDef = CHASSIS[cKey];
        this.player = {
            x: W/2, y: H/2, vx:0, vy:0, a: -1.57, hp: cDef.hp, maxHp: cDef.hp, vHp: cDef.hp, vHpLag: cDef.hp, spd: cDef.spd * SPEED_MULT, heatRate: cDef.heatRate,
            dmg: 10, rate: 12, bSize: 1, bSpd: 18, heat: 0, maxHeat: 100, coolRate: 0.25, overheated: false, vHeat: 0, ult: 0, maxUlt: 100, ultMult: 1, heatMult: 1, vUlt: 0,
            crit: 0.05, pierce: 0, bounce: 0, multi: 0, dodge: 0, turnRate: 0, flags: {}, augments: [], activeSynergies: [], invul: 0, leech: 0, blastRadius: 0, homing: 0, level: 1, currentXp: 0, xpToNext: 200
        };
        Data.equipped.mods.forEach(m => { if(MODULES[m]) MODULES[m].func(this.player, Data.modLevels[m]||1); });
        this.enemies=[]; this.bullets=[]; this.particles=[]; this.turrets=[]; this.floatingTexts=[];
        this.xp=0; this.bits=0; this.wave=1; this.kills=0; this.active=true; this.jamTimer = 0; this.rerollCost = 50; this.isTutorial = false;
        
        document.getElementById('tut-msg').style.display = 'none';
        this.startWave();
        document.getElementById('ui-hud').classList.remove('hidden'); document.querySelectorAll('.screen:not(#ui-hud)').forEach(s=>s.classList.add('hidden')); Loop();
    },

    startTutorial() {
        if(this.active) return;
        this.start();
        this.isTutorial = true; this.tutStep = 0; this.tutTimer = 0;
        this.player.hp = 9999; this.player.maxHp = 9999; // God mode for learning
        this.enemies = []; // Clear any wave enemies
        document.getElementById('tut-msg').style.display = 'block';
        document.getElementById('d-wave').innerText = "TUT";
        this.updateTutUI("INITIALIZING SYSTEM...");
        setTimeout(() => this.nextTutStep(), 1500);
    },

    updateTutUI(msg) {
        let t = document.getElementById('tut-msg');
        t.innerText = msg; t.style.animation = 'none'; t.offsetHeight; t.style.animation = 'glitchSkew 3s infinite';
    },

    nextTutStep() {
        this.tutStep++;
        if(this.tutStep === 1) this.updateTutUI("STEP 1: USE LEFT JOYSTICK TO MOVE");
        if(this.tutStep === 2) this.updateTutUI("STEP 2: USE RIGHT JOYSTICK TO FIRE");
        if(this.tutStep === 3) { 
            this.updateTutUI("STEP 3: DESTROY THE TARGET");
            this.enemies.push({ id:'drone', x:W/2, y:H/4, vx:0, vy:0, ang:1.57, hp:50, maxHp:50, type:'drone', r:20, c:'#ff0000', shape:'arrow', ai:'seek', spd:0.5, bits:0 });
        }
        if(this.tutStep === 4) {
            this.updateTutUI("STEP 4: TAP 'ULT' BUTTON (BELOW)");
            this.player.ult = 100;
        }
        if(this.tutStep === 5) {
            this.updateTutUI("TRAINING COMPLETE. GOOD LUCK.");
            setTimeout(() => { this.active = false; this.abort(); }, 3000);
        }
    },

    runTutorialLogic() {
        if(this.tutStep === 1) {
            if(Math.hypot(Input.lx, Input.ly) > 0.5) { this.tutTimer++; if(this.tutTimer > 60) { this.tutTimer=0; this.nextTutStep(); } }
        }
        if(this.tutStep === 2) {
            if(Math.hypot(Input.rx, Input.ry) > 0.5) { this.tutTimer++; if(this.tutTimer > 60) { this.tutTimer=0; this.nextTutStep(); } }
        }
        if(this.tutStep === 3) {
            if(this.enemies.length === 0) { this.tutTimer++; if(this.tutTimer > 60) { this.tutTimer=0; this.nextTutStep(); } }
        }
        if(this.tutStep === 4) {
            if(this.player.ult < 10) { this.tutTimer++; if(this.tutTimer > 60) { this.tutTimer=0; this.nextTutStep(); } }
            else this.player.ult = 100; // Keep it full until used
        }
    },

    showDamage(x, y, dmg, isCrit, color=null) {
        if(dmg < 1) return;
        this.floatingTexts.push({ x: x+(Math.random()-0.5)*20, y: y+(Math.random()-0.5)*20, text: Math.floor(dmg), life: 40, vy: -1.5, color: color ? color : (isCrit ? '#ffff00' : '#ffffff'), isCrit: isCrit, alpha: 1 });
    },

    startWave() {
        if(this.isTutorial) return;
        this.boss = (this.wave % 5 === 0);
        this.waveTotal = this.boss ? 1 : Math.max(5, (5 + Math.floor(this.wave * 1.5)) + (Math.floor(Math.random() * 7) - 3));
        this.spawnedCount = 0; this.spawnTimer = 0;
        document.getElementById('d-wave').innerText = this.wave; this.textFX("WAVE " + this.wave, '#fff');
        if (this.wave > Data.stats.highestWave) { Data.stats.highestWave = this.wave; this.checkAch(); }
    },

    togglePause() {
        if(document.getElementById('s-menu').classList.contains('hidden') === false) return;
        this.active = !this.active;
        let pScreen = document.getElementById('s-pause');
        let synList = this.player.activeSynergies.map(id => SYNERGIES.find(s=>s.id===id).n).join(', ') || 'NONE';
        document.getElementById('pause-syn').innerText = synList;
        if(!this.active) pScreen.classList.remove('hidden'); else { pScreen.classList.add('hidden'); Loop(); }
    },
    buyRepair() {
        if(this.bits >= 500 && this.player.hp < this.player.maxHp) {
            this.bits -= 500; this.player.hp = Math.min(this.player.maxHp, this.player.hp + (this.player.maxHp * 0.5));
            this.textFX("HULL REPAIRED", "#0f0"); this.updateHUD(); this.togglePause();
        } else alert("Insufficient Bits or Full HP");
    },
    rerollAugments() { if(this.bits >= this.rerollCost) { this.bits -= this.rerollCost; this.rerollCost += 50; this.showAugments(); } else alert("Not enough Bits!"); },
    abort() {
        this.active = false; document.getElementById('s-pause').classList.add('hidden'); document.getElementById('ui-hud').classList.add('hidden');
        document.getElementById('s-over').classList.add('hidden'); Menus.home();
    },
    triggerUlt() {
        if(this.player.ult < this.player.maxUlt) return;
        this.player.ult = 0; let c = CHASSIS[Data.equipped.chassis];
        this.textFX("SYSTEM: " + c.ult, c.color); this.player.heat = 0; this.player.overheated = false; this.jamTimer = 0;
        if(c.ult === 'OVERCLOCK') { this.player.rate=4; setTimeout(()=>{this.player.rate=15;}, 4000); }
        if(c.ult === 'REFLECT') { this.player.invul=300; this.player.flags.thorns=true; }
        if(c.ult === 'PHASE') { this.player.dodge+=0.9; setTimeout(()=>{this.player.dodge-=0.9;}, 4000); }
        if(c.ult === 'INFERNO') { this.enemies.forEach(e=>{e.hp-=150; this.showDamage(e.x,e.y,150,true,'#ff5500')}); this.shake=20; this.explosion(W/2,H/2,'#ff5500'); }
        if(c.ult === 'RAILGUN') { this.bullets.push({x:this.player.x, y:this.player.y, vx:Math.cos(this.player.a)*40, vy:Math.sin(this.player.a)*40, life:100, dmg:500, sz:50, pierce:99, color:'#39ff14', angle:this.player.a}); }
        if(c.ult === 'AEGIS') { this.player.hp = Math.min(this.player.hp+50, this.player.maxHp); this.player.flags.shield = true; }
        if(c.ult === 'OVERDRIVE') { this.player.flags.ram = true; let oldSpd = this.player.spd; this.player.spd *= 3; setTimeout(()=>{ this.player.flags.ram=false; this.player.spd=oldSpd; }, 4000); }
        if(c.ult === 'CONSTRUCT') { this.turrets.push({x:this.player.x, y:this.player.y, life:600, angle:0, cd:0}); }
        if(c.ult === 'DASH') { this.player.vx += Math.cos(this.player.a)*20; this.player.vy += Math.sin(this.player.a)*20; this.player.invul=30; }
        if(c.ult === 'BARRAGE') { for(let i=0; i<10; i++) { let a = (i/10)*6.28; this.bullets.push({x:this.player.x, y:this.player.y, vx:Math.cos(a)*10, vy:Math.sin(a)*10, life:80, dmg:40, sz:8, color:'#8b0000'}); } }
        if(c.ult === 'CLOAK') { this.player.flags.cloak = true; setTimeout(()=>{this.player.flags.cloak=false;}, 5000); }
        if(c.ult === 'SHIELD') { this.player.flags.energyShield = true; this.player.shieldHp = 200; setTimeout(()=>{this.player.flags.energyShield=false;}, 8000); }
    },

    update() {
        if(!this.active) return;
        if(this.isTutorial) this.runTutorialLogic();

        const P = this.player;
        P.vx = P.vx*0.9 + Input.lx*0.15*P.spd; P.vy = P.vy*0.9 + Input.ly*0.15*P.spd;
        P.x += P.vx; P.y += P.vy; P.x = Math.max(20, Math.min(W-20, P.x)); P.y = Math.max(20, Math.min(H-20, P.y));
        if(Math.abs(P.vx) > 0.1 || Math.abs(P.vy) > 0.1) P.a = Math.atan2(P.vy, P.vx);
        if(P.activeSynergies.includes('jug') && Math.abs(P.vx)<0.1 && Math.abs(P.vy)<0.1 && Game.frame%10===0) P.hp = Math.min(P.maxHp, P.hp + 2);
        if(!Input.ra || P.overheated) { let actualCool = P.overheated ? P.coolRate * 0.8 : P.coolRate; P.heat = Math.max(0, P.heat - actualCool); }
        if(this.jamTimer > 0) this.jamTimer--;
        if(P.heat >= P.maxHeat && !P.overheated) { P.overheated = true; P.heat = P.maxHeat; this.shake = 10; this.textFX("SYSTEM JAMMED", "#ff0000"); this.jamTimer = 60; }
        if(P.overheated && P.heat <= 0 && this.jamTimer <= 0) { P.overheated = false; this.textFX("SYSTEM COOLED", "#00ff00"); }

        if(!P.overheated && this.jamTimer <= 0) {
            document.getElementById('msg-oh').style.display='none';
            if(Input.ra && Game.frame % Math.floor(P.rate) === 0) { this.fire(); P.heat += (P.heatRate * P.heatMult) * 2.5; }
        } else {
            document.getElementById('msg-oh').style.display='block';
            if(Game.frame % 10 === 0) this.particles.push({x:P.x, y:P.y, vx:(Math.random()-0.5), vy:-2, life:30, c:'#555', sz:3});
        }
        
        if(P.flags.tesla) {
            let freq = P.activeSynergies.includes('storm') ? 20 : 45;
            if(Game.frame % freq === 0) {
                let t = this.getNearest(P.x, P.y);
                if(t && Math.hypot(t.x-P.x, t.y-P.y)<250) {
                    let tdmg = 15 * P.flags.tesla; t.hp -= tdmg; this.showDamage(t.x, t.y, tdmg, false, '#00f3ff');
                    this.particles.push({x:(P.x+t.x)/2, y:(P.y+t.y)/2, vx:0, vy:0, life:5, c:'#00f3ff', sz:1}); 
                    if(P.activeSynergies.includes('storm')) {
                        let t2 = this.getNearest(t.x, t.y, [t]);
                        if(t2 && Math.hypot(t2.x-t.x, t2.y-t.y)<150) {
                            t2.hp -= 15; this.showDamage(t2.x, t2.y, 15, false, '#00f3ff');
                            setTimeout(()=>{ctx.save(); ctx.strokeStyle='#00f3ff'; ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(t2.x,t2.y); ctx.stroke(); ctx.restore();}, 0);
                        }
                    }
                }
            }
        }
        
        for(let i=this.turrets.length-1; i>=0; i--) {
            let t = this.turrets[i]; t.life--; let target = this.getNearest(t.x, t.y);
            if(target) {
                t.angle = Math.atan2(target.y - t.y, target.x - t.x);
                if(t.cd<=0 && Math.hypot(target.x-t.x, target.y-t.y)<400) { this.bullets.push({x:t.x, y:t.y, vx:Math.cos(t.angle)*15, vy:Math.sin(t.angle)*15, life:60, dmg:15, sz:3, color:'#9d00ff', angle:t.angle}); t.cd = 20; }
            }
            if(t.cd>0) t.cd--; if(t.life<=0) this.turrets.splice(i,1);
        }

        if(!this.isTutorial) {
            if(this.spawnedCount < this.waveTotal) { this.spawnTimer--; if(this.spawnTimer <= 0) { this.spawn(); this.spawnTimer = 80 - Math.min(60, this.wave*2); } } 
            else if(this.enemies.length === 0) { this.showAugments(); return; }
        }
        
        let left = (this.waveTotal - this.spawnedCount) + this.enemies.length; if(this.boss) left = 1;
        document.getElementById('d-left').innerText = left;

        for(let i=this.enemies.length-1; i>=0; i--) this.updateEnemy(this.enemies[i], i);
        for(let i=this.bullets.length-1; i>=0; i--) this.updateBullet(this.bullets[i], i);
        for(let i=this.particles.length-1; i>=0; i--) { let p = this.particles[i]; p.life--; p.x+=p.vx; p.y+=p.vy; if(p.life<=0) this.particles.splice(i,1); }
        for(let i=this.floatingTexts.length-1; i>=0; i--) { let ft = this.floatingTexts[i]; ft.y += ft.vy; ft.life--; ft.alpha = ft.life > 10 ? 1 : ft.life/10; if(ft.life<=0) this.floatingTexts.splice(i,1); }
        
        if(P.invul>0) P.invul--; if(P.hp <= 0) this.over();
        this.updateHUD(); this.render();
    },

    updateEnemy(e, i) {
        const P = this.player; if(AI[e.ai]) AI[e.ai](e, P); else AI.seek(e, P);
        e.x += e.vx; e.y += e.vy; if(e.x < 10) e.vx += 1; if(e.x > W-10) e.vx -= 1; if(e.y < 10) e.vy += 1; if(e.y > H-10) e.vy -= 1;
        if(e.wpn && Game.frame % 120 === 0) {
            let ang = Math.atan2(P.y - e.y, P.x - e.x); let dmg = (10 + (this.wave * 2)) * (e.elite ? 2 : 1);
            if(e.wpn === 'pew') this.bullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*8, vy:Math.sin(ang)*8, life:100, dmg:dmg, sz:4, color:e.c, enemy:true});
            if(e.wpn === 'sniper') this.bullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*15, vy:Math.sin(ang)*15, life:100, dmg:dmg*3, sz:4, color:'#fff', enemy:true});
        }
        let d = Math.hypot(P.x - e.x, P.y - e.y);
        if(P.flags.ram && d < e.r + 30) { e.hp = 0; this.showDamage(e.x, e.y, 9999, true); this.explosion(e.x, e.y, e.c); this.shake = 10; } 
        else if(P.flags.orbit) {
             let t = Date.now()/300; let hitOrbit = false;
             for(let k=0; k<P.flags.orbit; k++) { let oa = t + (k * (6.28/P.flags.orbit)); let ox = P.x + Math.cos(oa)*40; let oy = P.y + Math.sin(oa)*40; if(Math.hypot(e.x-ox, e.y-oy) < e.r + 8) hitOrbit = true; }
             if(hitOrbit) { let odmg = 2; if(P.activeSynergies.includes('planet')) { this.explosion(e.x, e.y, '#ff5500'); e.hp-=5; odmg=5; } e.hp -= odmg; this.showDamage(e.x, e.y, odmg, false, '#ffd700'); this.particles.push({x:e.x, y:e.y, vx:0, vy:0, life:5, c:'#ffd700', sz:2}); }
        }
        if(d < e.r + 15 && P.invul<=0 && !P.flags.ram) {
             if(Math.random() < P.dodge) { this.textFX("DODGE", '#0ff'); P.invul=30; } else {
                 let dmg = (15 + this.wave + (e.tier*2)) * (e.elite ? 2 : 1); if(P.flags.shield) { dmg=0; P.flags.shield=false; } P.hp -= dmg; this.shake=10; P.invul=30; if(P.flags.thorns) { e.hp -= dmg*3; this.showDamage(e.x, e.y, dmg*3, true); }
             }
        }
        if(e.hp <= 0) this.killEnemy(e, i);
    },
    
    killEnemy(e, i) {
        this.enemies.splice(i, 1); this.kills++; this.bits += e.bits * (this.boss ? 10 : 1);
        let gain = e.bits * 10; this.xp += gain; this.player.currentXp += gain;
        if(this.player.currentXp >= this.player.xpToNext) this.levelUp();
        Data.stats.totalKills++; if(e.boss) Data.stats.bossKilled = true;
        let dist = Math.hypot(e.x - this.player.x, e.y - this.player.y); if(dist > 400) this.achFlags.longShot = true; if(dist < 50) this.achFlags.closeKill = true; this.checkAch();
        let P = this.player; if(P.leech > 0 && P.hp < P.maxHp) P.hp = Math.min(P.maxHp, P.hp + P.leech);
        if(e.frozen && P.activeSynergies.includes('shatter')) { for(let k=0; k<5; k++) { let a = k*(6.28/5); this.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*12, vy:Math.sin(a)*12, life:20, dmg:10, sz:3, color:'#00f3ff', angle:a}); } }
        P.ult = Math.min(P.maxUlt, P.ult + 7*P.ultMult);
        if(P.flags.nova && Math.random() < 0.3) { for(let k=0; k<6; k++) { let a = k*(6.28/6); this.bullets.push({x:e.x, y:e.y, vx:Math.cos(a)*10, vy:Math.sin(a)*10, life:30, dmg:20, sz:3, color:'#ff5500', angle:a}); } }
        this.explosion(e.x, e.y, e.c, e.elite ? 2 : 1);
        if(e.id === 'cube' && e.r > 10) { for(let k=0; k<2; k++) { this.enemies.push({...e, hp:e.hp/2, r:e.r/1.5, x:e.x+k*10, y:e.y+k*10, bits:1}); } }
    },

    levelUp() {
        const P = this.player; P.currentXp -= P.xpToNext; P.level++; P.xpToNext = Math.floor(P.xpToNext * 1.2);
        let roll = Math.random(); let txt = '';
        if(roll < 0.33) { P.dmg *= 1.05; txt = '+5% DMG'; } else if (roll < 0.66) { P.maxHp += 10; P.hp += 10; txt = '+10 MAX HP'; } else { P.crit += 0.02; txt = '+2% CRIT'; }
        document.getElementById('lvl-bonus').innerText = txt; let msg = document.getElementById('lvl-up-msg'); msg.classList.remove('show'); void msg.offsetWidth; msg.classList.add('show');
    },

    updateBullet(b, i) {
        if(this.player.homing > 0 && !b.enemy) {
            let t = this.getNearest(b.x, b.y);
            if(t) {
                let ta = Math.atan2(t.y - b.y, t.x - b.x); let turn = this.player.homing; if(this.player.activeSynergies.includes('curve')) turn *= 2; 
                let diff = ta - b.angle; while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
                b.angle += Math.max(-turn, Math.min(turn, diff)); let s = Math.hypot(b.vx, b.vy); b.vx = Math.cos(b.angle) * s; b.vy = Math.sin(b.angle) * s;
            }
        }
        else if(b.turnRate && !b.enemy) {
            let t = this.getNearest(b.x, b.y);
            if(t) {
                let ta = Math.atan2(t.y - b.y, t.x - b.x), diff = ta - b.angle; while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
                b.angle += Math.max(-b.turnRate, Math.min(b.turnRate, diff)); let s = Math.hypot(b.vx, b.vy); b.vx = Math.cos(b.angle) * s; b.vy = Math.sin(b.angle) * s;
            }
        }
        b.x += b.vx; b.y += b.vy; b.life--;
        let hitWall = false; if(b.x < 0) { b.x = 0; b.vx *= -1; hitWall=true; } if(b.x > W) { b.x = W; b.vx *= -1; hitWall=true; } if(b.y < 0) { b.y = 0; b.vy *= -1; hitWall=true; } if(b.y > H) { b.y = H; b.vy *= -1; hitWall=true; }
        if(hitWall) { if(b.bounce > 0) { b.bounce--; b.angle = Math.atan2(b.vy, b.vx); if(this.player.activeSynergies.includes('geom')) b.dmg *= 1.5; } else if (!b.enemy) { this.bullets.splice(i,1); return; } }
        if(b.life<=0) { this.bullets.splice(i,1); return; }
        if(!b.enemy) {
            for(let j=this.enemies.length-1; j>=0; j--) {
                let e = this.enemies[j];
                if(Math.hypot(e.x-b.x, e.y-b.y) < e.r + b.sz + 5) {
                    let dmg = b.dmg; e.hp -= dmg; this.showDamage(e.x, e.y, dmg, b.crit); if(this.player.flags.frost) e.frozen = true;
                    if(this.player.blastRadius > 0) { this.explosion(b.x, b.y, '#ff5500', 3); this.enemies.forEach(e2 => { if(Math.hypot(e2.x-b.x, e2.y-b.y) < this.player.blastRadius) { e2.hp -= dmg * 0.5; this.showDamage(e2.x, e2.y, dmg*0.5, false, '#ff5500'); } }); }
                    this.particles.push({x:b.x, y:b.y, vx:Math.random()-0.5, vy:Math.random()-0.5, life:8, c:b.color||'#fff', sz:2});
                    if(b.pierce>0) b.pierce--; else { this.bullets.splice(i,1); break; }
                }
            }
        } else {
            let blocked = false;
            if(this.player.flags.orbit) {
                let t = Date.now()/300; for(let k=0; k<this.player.flags.orbit; k++) { let oa = t + (k * (6.28/this.player.flags.orbit)); let ox = this.player.x + Math.cos(oa)*40; let oy = this.player.y + Math.sin(oa)*40; if(Math.hypot(ox-b.x, oy-b.y) < 15) blocked = true; }
            }
            if(blocked) { this.particles.push({x:b.x, y:b.y, vx:0, vy:0, life:10, c:'#ffd700', sz:3}); this.bullets.splice(i,1); return; }
            if(Math.hypot(this.player.x-b.x, this.player.y-b.y) < 15 && this.player.invul<=0 && !this.player.flags.ram) { this.player.hp -= b.dmg; this.shake=5; this.player.invul=20; this.bullets.splice(i,1); }
        }
    },

    spawn() {
        if(this.boss && this.enemies.length === 0 && this.spawnedCount === 0) {
            let bossIndex = Math.floor(this.wave / 5) - 1; let bossDef = BOSS_DB[bossIndex % BOSS_DB.length];
            let hp = bossDef.hp + (this.wave * 200); this.enemies.push({ x: W/2, y: -100, vx:0, vy:0, ang: 1.57, hp: hp, maxHp: hp, type: 'boss', id: bossDef.id, boss: true, tier: 6, spd: bossDef.spd * SPEED_MULT, c: bossDef.c, r: bossDef.r, shape: bossDef.shape, ai: bossDef.ai, bits: bossDef.bits, turnRate: 0.02 });
            this.textFX("WARNING: " + bossDef.name.toUpperCase() + " DETECTED", bossDef.c); this.spawnedCount++; return;
        }
        if(this.boss) return;
        let t = 1; if(this.wave >= 3) t = 2; if(this.wave >= 6) t = 3; if(this.wave >= 9) t = 4;
        let pool = ENEMY_DB.filter(e => e.tier <= t); let template = pool[Math.floor(Math.random() * pool.length)];
        let ang = Math.random()*6.28, dist = Math.max(W,H)/1.2; let sx = W/2 + Math.cos(ang)*dist, sy = H/2 + Math.sin(ang)*dist; let scaleMult = 1 + (this.wave * 0.15); let isElite = Math.random() < 0.05;
        if(isElite) { this.textFX("ELITE HOSTILE DETECTED", "#ffd700"); }
        this.enemies.push({ ...template, x: sx, y: sy, vx: 0, vy: 0, ang: Math.atan2(H/2 - sy, W/2 - sx), spd: (template.spd || 1) * SPEED_MULT, hp: template.hp * scaleMult * (isElite ? 3 : 1), maxHp: template.hp * scaleMult * (isElite ? 3 : 1), turnRate: 0.03 + (Math.random()*0.02), charge: 0, type: template.id, elite: isElite, r: template.r * (isElite ? 1.5 : 1), c: isElite ? '#ffd700' : template.c, bits: template.bits * (isElite ? 5 : 1) });
        this.spawnedCount++;
    },

    fire() {
        const P = this.player; let c = 1 + P.multi; if(P.activeSynergies.includes('star')) c += 7; 
        let arc = P.spread || 0.15; if(P.activeSynergies.includes('star')) arc = 6.28/8;
        let aimA = Math.atan2(Input.ry, Input.rx); let start = aimA - (arc * (c-1))/2; if(P.activeSynergies.includes('star')) start = aimA;
        let crit = Math.random() < P.crit; let color = crit ? '#ff0' : '#0ff';
        for(let i=0; i<c; i++) { let a = start + i*arc; this.bullets.push({ x:P.x, y:P.y, vx:Math.cos(a)*P.bSpd, vy:Math.sin(a)*P.bSpd, life:60, dmg:P.dmg * (crit?2:1), sz:3*P.bSize, crit:crit, pierce:P.pierce, bounce:P.bounce, turnRate:P.turnRate, angle:a, color:color }); }
        if(P.flags.rear) { let ra = aimA + Math.PI; this.bullets.push({ x:P.x, y:P.y, vx:Math.cos(ra)*P.bSpd, vy:Math.sin(ra)*P.bSpd, life:60, dmg:P.dmg, sz:3*P.bSize, pierce:P.pierce, bounce:P.bounce, angle:ra, color:color }); }
    },

    explosion(x, y, c, scale=1) { for(let i=0; i<8*scale; i++) this.particles.push({ x:x, y:y, vx:(Math.random()-0.5)*8*scale, vy:(Math.random()-0.5)*8*scale, life:20 + Math.random()*15, c:c, sz:Math.random()*4*scale }); },

    render() {
        ctx.clearRect(0,0,W,H); ctx.save();
        if(this.shake > 0) { ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake); this.shake *= 0.9; if(this.shake < 0.5) this.shake = 0; }
        Draw.stars(Game.frame, this.player);
        ctx.globalCompositeOperation = 'lighter'; this.particles.forEach(p => { ctx.fillStyle = p.c; ctx.globalAlpha = p.life/30; ctx.beginPath(); ctx.arc(p.x, p.y, p.sz, 0, 6.28); ctx.fill(); }); ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
        this.turrets.forEach(t => Draw.turret(ctx, t));
        Draw.ship(ctx, this.player.x, this.player.y, this.player.a, Data.equipped.chassis, CHASSIS[Data.equipped.chassis].color, Data.equipped.mods, this.player.overheated);
        this.enemies.forEach(e => {
            if(e.type === 'sniper') { ctx.save(); ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)'; ctx.setLineDash([10, 10]); ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(this.player.x, this.player.y); ctx.stroke(); ctx.restore(); }
            if(this.player.flags.tesla && Math.hypot(e.x-this.player.x, e.y-this.player.y)<250 && Game.frame%5===0) { ctx.beginPath(); ctx.moveTo(this.player.x, this.player.y); ctx.lineTo(e.x,e.y); ctx.strokeStyle = `rgba(0, 243, 255, ${Math.random()})`; ctx.stroke(); }
            Draw.enemy(ctx, e);
        });
        this.bullets.forEach(b => { ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.shadowBlur = 15; ctx.shadowColor = b.color; ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.sz, 0, 6.28); ctx.fill(); ctx.restore(); });
        ctx.font = "bold 12px Orbitron"; ctx.textAlign = "center";
        this.floatingTexts.forEach(ft => { ctx.fillStyle = ft.color; ctx.globalAlpha = ft.alpha; if(ft.isCrit) ctx.font = "bold 16px Orbitron"; else ctx.font = "12px Orbitron"; ctx.fillText(ft.text, ft.x, ft.y); });
        ctx.restore();
    },
    
    getNearest(x, y, ignore=[]) { let t=null, d=9999; this.enemies.forEach(e=>{ if(ignore.includes(e)) return; let dist=Math.hypot(e.x-x, e.y-y); if(dist<d){d=dist;t=e;} }); return t; },
    
    updateHUD() {
        const P = this.player; P.vHp += (P.hp - P.vHp) * 0.1; P.vHpLag += (P.hp - P.vHpLag) * 0.02; P.vHeat += (P.heat - P.vHeat) * 0.1; P.vUlt += (P.ult - P.vUlt) * 0.1;
        document.getElementById('hp-bar').style.width = Math.max(0, (P.vHp / P.maxHp * 100)) + '%';
        document.getElementById('hp-lag').style.width = Math.max(0, (P.vHpLag / P.maxHp * 100)) + '%';
        document.getElementById('heat-bar').style.width = (P.vHeat / P.maxHeat * 100) + '%';
        document.getElementById('ult-bar').style.width = (P.vUlt / P.maxUlt * 100) + '%';
        document.getElementById('xp-bar-fill').style.width = Math.min(100, (P.currentXp / P.xpToNext) * 100) + '%';
        let hFrame = document.getElementById('heat-frame');
        if(this.jamTimer > 0) { hFrame.classList.add('jammed'); document.getElementById('heat-txt').innerText = "JAMMED"; } else { hFrame.classList.remove('jammed'); document.getElementById('heat-txt').innerText = "HEAT"; }
        let uBtn = document.getElementById('btn-ult'); if(P.ult >= P.maxUlt) uBtn.classList.add('ready'); else uBtn.classList.remove('ready');
        document.getElementById('d-bits').innerText = this.bits; document.getElementById('d-lvl').innerText = P.level;
    },

    showAugments() {
        this.active = false;
        if(this.player.hp >= this.player.maxHp && this.wave === 5) this.achFlags.untouchable = true;
        this.checkAch();
        let c = document.getElementById('card-con'); c.innerHTML = '';
        let pool = [...AUG_POOL]; pool.sort(() => Math.random() - 0.5);
        for(let i=0; i<Math.min(3, pool.length); i++) {
            let rnd = pool[i]; let d = document.createElement('div'); d.className = 'card';
            d.innerHTML = `<span class="card-type">${rnd.type}</span><h3 style="color:var(--cyan)">${rnd.n}</h3><p>${rnd.d}</p>`;
            d.onclick = () => {
                rnd.f(this.player); this.player.augments.push(rnd.id); this.checkSynergies(); document.getElementById('s-up').classList.add('hidden');
                this.wave++; this.active = true; this.startWave(); Loop();
            }; c.appendChild(d);
        }
        document.getElementById('btn-reroll').innerText = `REROLL (${this.rerollCost} BITS)`; document.getElementById('s-up').classList.remove('hidden');
    },

    checkSynergies() {
        const P = this.player;
        SYNERGIES.forEach(s => {
            if(P.activeSynergies.includes(s.id)) return;
            let hasMod = (!s.mod) || Data.equipped.mods.includes(s.mod); let hasAugs = s.req.every(r => P.augments.includes(r) || Data.equipped.mods.includes(r));
            if(hasMod && hasAugs) { P.activeSynergies.push(s.id); this.textFX("SYNERGY UNLOCKED: " + s.n, '#ffd700'); setTimeout(() => { alert(`SYNERGY ACQUIRED: ${s.n}\n\n${s.d}`); }, 100); this.checkAch(); }
        });
    },
    achFlags: { longShot: false, closeKill: false, untouchable: false },
    checkAch() {
        let s = { totalKills: Data.stats.totalKills, highestWave: Data.stats.highestWave, currentBits: this.active ? this.bits + Data.bits : Data.bits, synergyUnlocked: this.player.activeSynergies && this.player.activeSynergies.length > 0, maxedMod: Object.values(Data.modLevels).some(l => l >= 5), ownedChassis: Data.owned.length, bossKilled: Data.stats.bossKilled, longShot: this.achFlags.longShot, closeKill: this.achFlags.closeKill, untouchable: this.achFlags.untouchable };
        ACHIEVEMENTS.forEach(a => { if (!Data.achievements.includes(a.id) && a.req(s)) { Data.achievements.push(a.id); Data.bits += a.reward; if(this.active) this.bits += a.reward; this.notifyAch(a); localStorage.setItem(SAVE_KEY, JSON.stringify(Data)); } });
    },
    notifyAch(a) { let n = document.getElementById('ach-notify'); document.getElementById('ach-txt').innerText = a.name; document.getElementById('ach-rew').innerText = `+${a.reward} BITS`; n.classList.add('show'); setTimeout(() => n.classList.remove('show'), 3000); },
    textFX(t, c) { let d = document.createElement('div'); d.style.position='absolute'; d.style.top='30%'; d.style.width='100%'; d.style.textAlign='center'; d.style.color=c; d.style.fontFamily='Orbitron'; d.style.fontSize='24px'; d.style.textShadow='0 0 20px '+c; d.style.zIndex = 20; d.innerText = t; document.body.appendChild(d); setTimeout(()=>d.remove(), 2000); },
    over() { this.active = false; document.getElementById('ui-hud').classList.add('hidden'); document.getElementById('s-over').classList.remove('hidden'); document.getElementById('go-xp').innerText = this.xp; document.getElementById('go-bits').innerText = this.bits; let c = Data.equipped.chassis; Data.chassisXP[c].xp += this.xp; Data.bits += this.bits; Data.stats.highestWave = Math.max(Data.stats.highestWave, this.wave); this.checkAch(); localStorage.setItem(SAVE_KEY, JSON.stringify(Data)); submitScore(this.wave, this.kills, this.bits); }
};

let ShopTab = 'CHASSIS'; let previewId = null;
window.handleShopAction = function(mode, itemKey, cost, type) {
     if(mode === 'shop') {
         if(Data.bits >= cost) { Data.bits -= cost; if(type==='CHASSIS') { Data.owned.push(itemKey); Data.chassisXP[itemKey]={xp:0,lvl:1}; } else { Data.modules.push(itemKey); Data.modLevels[itemKey]=1; } Game.checkAch(); localStorage.setItem(SAVE_KEY, JSON.stringify(Data)); Menus.open('shop'); }
     } else if(mode === 'hangar') {
         if(type==='CHASSIS') { if(Data.equipped.chassis !== itemKey) { Data.equipped.chassis=itemKey; localStorage.setItem(SAVE_KEY, JSON.stringify(Data)); Menus.open('hangar'); } } 
         else { let eq = Data.equipped.mods.includes(itemKey); if(eq) Data.equipped.mods = Data.equipped.mods.filter(m=>m!==itemKey); else if(Data.equipped.mods.length<2) Data.equipped.mods.push(itemKey); localStorage.setItem(SAVE_KEY, JSON.stringify(Data)); Menus.open('hangar'); }
     } else if(mode === 'lab') {
         if(Data.bits >= cost) { Data.bits -= cost; if(type==='CHASSIS') Data.chassisXP[itemKey].lvl++; else Data.modLevels[itemKey]++; Game.checkAch(); localStorage.setItem(SAVE_KEY, JSON.stringify(Data)); Menus.open('lab'); }
     }
};
const Menus = {
    setShopTab(t) { ShopTab = t; Menus.open('shop'); },
    open(mode) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        if(previewId) { cancelAnimationFrame(previewId); previewId=null; }
        if (mode === 'achievements') {
            document.getElementById('s-ach').classList.remove('hidden');
            document.querySelector('#s-ach h2').innerText = 'ACHIEVEMENTS';
            document.querySelector('#s-ach .cyber-panel').style.borderColor = 'var(--gold)';
            let list = document.getElementById('ach-list'); list.innerHTML = ''; let unlockedCount = 0;
            ACHIEVEMENTS.forEach(a => { let unlocked = Data.achievements.includes(a.id); if(unlocked) unlockedCount++; let card = document.createElement('div'); card.className = `ach-card ${unlocked ? 'unlocked' : ''}`; card.innerHTML = `<h4 style="margin:0 0 5px 0; color:${unlocked ? 'var(--gold)' : '#555'}">${a.name}</h4><span class="ach-desc" style="font-size:11px; color:#888;">${a.desc}</span><div class="ach-reward" style="color:${unlocked?'var(--cyan)':'#444'}">+${a.reward} BITS</div>`; list.appendChild(card); });
            document.getElementById('ach-count').innerText = `${unlockedCount}/${ACHIEVEMENTS.length}`; return;
        } else if (mode === 'leaderboard') {
            document.getElementById('s-ach').classList.remove('hidden');
            document.querySelector('#s-ach h2').innerText = 'GLOBAL LEADERBOARD';
            document.querySelector('#s-ach .cyber-panel').style.borderColor = 'var(--pink)';
            let list = document.getElementById('ach-list');
            list.innerHTML = '<div style="text-align:center; color:#aaa;">Loading leaderboard...</div>';
            getLeaderboard().then(data => {
                list.innerHTML = '';
                data.entries.forEach(entry => {
                    let card = document.createElement('div');
                    card.className = 'ach-card unlocked';
                    card.innerHTML = `<h4 style="margin:0 0 5px 0; color:var(--gold)">${entry.playerName}</h4><span class="ach-desc" style="font-size:11px; color:#888;">Wave ${entry.wave} | Kills ${entry.kills} | Bits ${entry.bits}</span><div class="ach-reward" style="color:var(--cyan)">#${entry.rank}</div>`;
                    list.appendChild(card);
                });
            });
            return;
        }
        document.getElementById('s-list').classList.remove('hidden'); document.getElementById('list-title').innerText = mode.toUpperCase(); document.getElementById('ui-bits').innerText = Data.bits;
        const lst = document.getElementById('list-items'); const det = document.getElementById('list-detail'); const tabRow = document.getElementById('list-tabs'); lst.innerHTML = ''; det.innerHTML = '';
        if(mode === 'shop') { tabRow.style.display = 'flex'; if(ShopTab === 'CHASSIS') { document.getElementById('tab-chassis').style.borderColor = 'var(--cyan)'; document.getElementById('tab-modules').style.borderColor = '#333'; } else { document.getElementById('tab-chassis').style.borderColor = '#333'; document.getElementById('tab-modules').style.borderColor = 'var(--cyan)'; } } else tabRow.style.display = 'none';
        let items = [];
        if(mode === 'shop') { if(ShopTab === 'CHASSIS') { Object.keys(CHASSIS).forEach(k => { if(!Data.owned.includes(k)) items.push({k, ...CHASSIS[k], type:'CHASSIS'}); }); } else { Object.keys(MODULES).forEach(k => { if(!Data.modules.includes(k)) items.push({k, ...MODULES[k], type:'MODULE'}); }); } } else if (mode === 'hangar' || mode === 'lab') { Data.owned.forEach(k => items.push({k, ...CHASSIS[k], type:'CHASSIS'})); Data.modules.forEach(k => items.push({k, ...MODULES[k], type:'MODULE'})); }
        items.forEach(i => {
            let row = document.createElement('div'); row.className = 'row'; if(Data.equipped.chassis === i.k || Data.equipped.mods.includes(i.k)) row.classList.add('active');
            row.innerHTML = `<span>${i.name}</span><span style="font-size:10px">${i.type}</span>`;
            row.onclick = () => {
                if(previewId) cancelAnimationFrame(previewId);
                let btnTxt='', info=i.desc, actCost=0;
                if(mode==='shop') { btnTxt = `BUY ${i.cost}`; actCost=i.cost; } else if (mode==='hangar') { if(i.type==='CHASSIS') { if(Data.equipped.chassis !== i.k) btnTxt='EQUIP'; } else { btnTxt = Data.equipped.mods.includes(i.k) ? 'UNEQUIP' : 'EQUIP'; } } else if (mode==='lab') { let lvl = i.type==='CHASSIS' ? Data.chassisXP[i.k].lvl : Data.modLevels[i.k]; actCost = lvl*500; info = `Level: ${lvl}<br><span style="color:#888; font-size:12px;">Upgrade: ${actCost} Bits</span>`; if(lvl<10) btnTxt=`UPGRADE`; }
                det.innerHTML = `<h2 style="color:${i.color||'var(--cyan)'}; margin:0; border:none;">${i.name}</h2><div style="width:180px; height:180px; border:1px solid #333; margin:15px 0; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; position:relative;"><canvas id="prev-c" width="160" height="160"></canvas></div><p style="text-align:center; font-size:13px; color:#aaa; margin-bottom:20px;">${info}</p>${btnTxt ? `<button class="btn" onclick="window.handleShopAction('${mode}', '${i.k}', ${actCost}, '${i.type}')">${btnTxt}</button>` : ''}`;
                let pc = document.getElementById('prev-c'); let pctx = pc.getContext('2d'); let ang = -1.57;
                const anim = () => { pctx.clearRect(0,0,160,160); pctx.save(); pctx.translate(80,80); pctx.scale(2.5, 2.5); ang += 0.02; if(i.type==='CHASSIS') Draw.ship(pctx, 0, 0, ang, i.k, i.color, Data.equipped.mods); else Draw.ship(pctx, 0, 0, ang, Data.equipped.chassis, '#555', [i.k]); pctx.restore(); previewId = requestAnimationFrame(anim); }; anim();
            }; lst.appendChild(row);
        });
        setTimeout(setupButtonHandlers, 100);
    }, home() { if(previewId) { cancelAnimationFrame(previewId); previewId=null; } document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden')); document.getElementById('s-menu').classList.remove('hidden'); setTimeout(setupButtonHandlers, 100); }
};

let s = localStorage.getItem(SAVE_KEY); if(s) { Data = {...Data, ...JSON.parse(s)}; if(!Data.achievements) Data.achievements = []; if(!Data.stats) Data.stats = { totalKills: 0, highestWave: 0, bossKilled: false }; }
Data.owned.forEach(c => { if(!Data.chassisXP[c]) Data.chassisXP[c] = {xp:0, lvl:1}; }); Data.modules.forEach(m => { if(!Data.modLevels[m]) Data.modLevels[m] = 1; });
Input.init(); InitStars();
function Loop() { Game.frame++; Game.update(); if(Game.active) requestAnimationFrame(Loop); }

// Initialize menu on page load
window.addEventListener('DOMContentLoaded', () => { Menus.home(); setupButtonHandlers(); });
// Also try showing menu immediately
setTimeout(() => { 
    if(!Game.active) { 
        document.getElementById('s-menu').classList.remove('hidden');
        setupButtonHandlers();
    } 
}, 100);
</script>
</body>
</html>
